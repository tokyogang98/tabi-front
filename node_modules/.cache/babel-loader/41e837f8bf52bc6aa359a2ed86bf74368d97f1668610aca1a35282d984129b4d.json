{"ast":null,"code":"const ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\nexport default class KDBush {\n  /**\n   * Creates an index from raw `ArrayBuffer` data.\n   * @param {ArrayBuffer} data\n   */\n  static from(data) {\n    if (!(data instanceof ArrayBuffer)) {\n      throw new Error('Data must be an instance of ArrayBuffer.');\n    }\n    const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n    if (magic !== 0xdb) {\n      throw new Error('Data does not appear to be in a KDBush format.');\n    }\n    const version = versionAndType >> 4;\n    if (version !== VERSION) {\n      throw new Error(`Got v${version} data when expected v${VERSION}.`);\n    }\n    const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n    if (!ArrayType) {\n      throw new Error('Unrecognized array type.');\n    }\n    const [nodeSize] = new Uint16Array(data, 2, 1);\n    const [numItems] = new Uint32Array(data, 4, 1);\n    return new KDBush(numItems, nodeSize, ArrayType, data);\n  }\n\n  /**\n   * Creates an index that will hold a given number of items.\n   * @param {number} numItems\n   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n   * @param {ArrayBuffer} [data] (For internal use only)\n   */\n  constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n    if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n    this.numItems = +numItems;\n    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    this.ArrayType = ArrayType;\n    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n    const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n    const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n    const padCoords = (8 - idsByteSize % 8) % 8;\n    if (arrayTypeIndex < 0) {\n      throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n    }\n    if (data && data instanceof ArrayBuffer) {\n      // reconstruct an index from a buffer\n      this.data = data;\n      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n      this._pos = numItems * 2;\n      this._finished = true;\n    } else {\n      // initialize a new index\n      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n      this._pos = 0;\n      this._finished = false;\n\n      // set header\n      new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n      new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n      new Uint32Array(this.data, 4, 1)[0] = numItems;\n    }\n  }\n\n  /**\n   * Add a point to the index.\n   * @param {number} x\n   * @param {number} y\n   * @returns {number} An incremental index associated with the added item (starting from `0`).\n   */\n  add(x, y) {\n    const index = this._pos >> 1;\n    this.ids[index] = index;\n    this.coords[this._pos++] = x;\n    this.coords[this._pos++] = y;\n    return index;\n  }\n\n  /**\n   * Perform indexing of the added points.\n   */\n  finish() {\n    const numAdded = this._pos >> 1;\n    if (numAdded !== this.numItems) {\n      throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n    }\n    // kd-sort both arrays for efficient search\n    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n    this._finished = true;\n    return this;\n  }\n\n  /**\n   * Search the index for items within a given bounding box.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @returns {number[]} An array of indices correponding to the found items.\n   */\n  range(minX, minY, maxX, maxY) {\n    if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n    const {\n      ids,\n      coords,\n      nodeSize\n    } = this;\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n\n    // recursively search for items in range in the kd-sorted arrays\n    while (stack.length) {\n      const axis = stack.pop() || 0;\n      const right = stack.pop() || 0;\n      const left = stack.pop() || 0;\n\n      // if we reached \"tree node\", search linearly\n      if (right - left <= nodeSize) {\n        for (let i = left; i <= right; i++) {\n          const x = coords[2 * i];\n          const y = coords[2 * i + 1];\n          if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n        }\n        continue;\n      }\n\n      // otherwise find the middle index\n      const m = left + right >> 1;\n\n      // include the middle item if it's in range\n      const x = coords[2 * m];\n      const y = coords[2 * m + 1];\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n      // queue search in halves that intersect the query\n      if (axis === 0 ? minX <= x : minY <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(1 - axis);\n      }\n      if (axis === 0 ? maxX >= x : maxY >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(1 - axis);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Search the index for items within a given radius.\n   * @param {number} qx\n   * @param {number} qy\n   * @param {number} r Query radius.\n   * @returns {number[]} An array of indices correponding to the found items.\n   */\n  within(qx, qy, r) {\n    if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n    const {\n      ids,\n      coords,\n      nodeSize\n    } = this;\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    // recursively search for items within radius in the kd-sorted arrays\n    while (stack.length) {\n      const axis = stack.pop() || 0;\n      const right = stack.pop() || 0;\n      const left = stack.pop() || 0;\n\n      // if we reached \"tree node\", search linearly\n      if (right - left <= nodeSize) {\n        for (let i = left; i <= right; i++) {\n          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n        }\n        continue;\n      }\n\n      // otherwise find the middle index\n      const m = left + right >> 1;\n\n      // include the middle item if it's in range\n      const x = coords[2 * m];\n      const y = coords[2 * m + 1];\n      if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n      // queue search in halves that intersect the query\n      if (axis === 0 ? qx - r <= x : qy - r <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(1 - axis);\n      }\n      if (axis === 0 ? qx + r >= x : qy + r >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(1 - axis);\n      }\n    }\n    return result;\n  }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n  if (right - left <= nodeSize) return;\n  const m = left + right >> 1; // middle index\n\n  // sort ids and coords around the middle index so that the halves lie\n  // either left/right or top/bottom correspondingly (taking turns)\n  select(ids, coords, m, left, right, axis);\n\n  // recursively kd-sort first half and second half on the opposite axis\n  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n  while (right > left) {\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      select(ids, coords, k, newLeft, newRight, axis);\n    }\n    const t = coords[2 * k + axis];\n    let i = left;\n    let j = right;\n    swapItem(ids, coords, left, k);\n    if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n    while (i < j) {\n      swapItem(ids, coords, i, j);\n      i++;\n      j--;\n      while (coords[2 * i + axis] < t) i++;\n      while (coords[2 * j + axis] > t) j--;\n    }\n    if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);else {\n      j++;\n      swapItem(ids, coords, j, right);\n    }\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n  swap(ids, i, j);\n  swap(coords, 2 * i, 2 * j);\n  swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n  const tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n  const dx = ax - bx;\n  const dy = ay - by;\n  return dx * dx + dy * dy;\n}","map":{"version":3,"names":["ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","VERSION","HEADER_SIZE","KDBush","from","data","ArrayBuffer","Error","magic","versionAndType","version","ArrayType","nodeSize","numItems","constructor","isNaN","Math","min","max","IndexArrayType","arrayTypeIndex","indexOf","coordsByteSize","BYTES_PER_ELEMENT","idsByteSize","padCoords","ids","coords","_pos","_finished","set","add","x","y","index","finish","numAdded","sort","range","minX","minY","maxX","maxY","stack","length","result","axis","pop","right","left","i","push","m","within","qx","qy","r","r2","sqDist","select","k","n","z","log","s","exp","sd","sqrt","newLeft","floor","newRight","t","j","swapItem","swap","arr","tmp","ax","ay","bx","by","dx","dy"],"sources":["/Users/yoomin/Documents/GitHub/tabi/node_modules/kdbush/index.js"],"sourcesContent":["\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nexport default class KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}