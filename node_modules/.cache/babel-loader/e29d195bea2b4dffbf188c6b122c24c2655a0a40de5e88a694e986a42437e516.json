{"ast":null,"code":"import KDBush from 'kdbush';\nconst defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => x => {\n  tmp[0] = +x;\n  return tmp[0];\n})(new Float32Array(1));\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\nexport default class Supercluster {\n  constructor(options) {\n    this.options = Object.assign(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n    this.stride = this.options.reduce ? 7 : 6;\n    this.clusterProps = [];\n  }\n  load(points) {\n    const {\n      log,\n      minZoom,\n      maxZoom\n    } = this.options;\n    if (log) console.time('total time');\n    const timerId = `prepare ${points.length} points`;\n    if (log) console.time(timerId);\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    const data = [];\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i];\n      if (!p.geometry) continue;\n      const [lng, lat] = p.geometry.coordinates;\n      const x = fround(lngX(lng));\n      const y = fround(latY(lat));\n      // store internal point/cluster data in flat numeric arrays for performance\n      data.push(x, y,\n      // projected point coordinates\n      Infinity,\n      // the last zoom the point was processed at\n      i,\n      // index of the source feature in the original input array\n      -1,\n      // parent cluster id\n      1 // number of points in a cluster\n      );\n\n      if (this.options.reduce) data.push(0); // noop\n    }\n\n    let tree = this.trees[maxZoom + 1] = this._createTree(data);\n    if (log) console.timeEnd(timerId);\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (let z = maxZoom; z >= minZoom; z--) {\n      const now = +Date.now();\n\n      // create a new set of clusters for the zoom and index them with a KD-tree\n      tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n      if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n    }\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n  getClusters(bbox, zoom) {\n    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n    const tree = this.trees[this._limitZoom(zoom)];\n    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    const data = tree.data;\n    const clusters = [];\n    for (const id of ids) {\n      const k = this.stride * id;\n      clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n    }\n    return clusters;\n  }\n  getChildren(clusterId) {\n    const originId = this._getOriginId(clusterId);\n    const originZoom = this._getOriginZoom(clusterId);\n    const errorMsg = 'No cluster with the specified id.';\n    const tree = this.trees[originZoom];\n    if (!tree) throw new Error(errorMsg);\n    const data = tree.data;\n    if (originId * this.stride >= data.length) throw new Error(errorMsg);\n    const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    const x = data[originId * this.stride];\n    const y = data[originId * this.stride + 1];\n    const ids = tree.within(x, y, r);\n    const children = [];\n    for (const id of ids) {\n      const k = id * this.stride;\n      if (data[k + OFFSET_PARENT] === clusterId) {\n        children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n      }\n    }\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    const leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n    return leaves;\n  }\n  getTile(z, x, y) {\n    const tree = this.trees[this._limitZoom(z)];\n    const z2 = Math.pow(2, z);\n    const {\n      extent,\n      radius\n    } = this.options;\n    const p = radius / extent;\n    const top = (y - p) / z2;\n    const bottom = (y + 1 + p) / z2;\n    const tile = {\n      features: []\n    };\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.data, x, y, z2, tile);\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.data, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.data, -1, y, z2, tile);\n    }\n    return tile.features.length ? tile : null;\n  }\n  getClusterExpansionZoom(clusterId) {\n    let expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n      const children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n  }\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    const children = this.getChildren(clusterId);\n    for (const child of children) {\n      const props = child.properties;\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n          // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n      if (result.length === limit) break;\n    }\n    return skipped;\n  }\n  _createTree(data) {\n    const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n    for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n    tree.finish();\n    tree.data = data;\n    return tree;\n  }\n  _addTileFeatures(ids, data, x, y, z2, tile) {\n    for (const i of ids) {\n      const k = i * this.stride;\n      const isCluster = data[k + OFFSET_NUM] > 1;\n      let tags, px, py;\n      if (isCluster) {\n        tags = getClusterProperties(data, k, this.clusterProps);\n        px = data[k];\n        py = data[k + 1];\n      } else {\n        const p = this.points[data[k + OFFSET_ID]];\n        tags = p.properties;\n        const [lng, lat] = p.geometry.coordinates;\n        px = lngX(lng);\n        py = latY(lat);\n      }\n      const f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags\n      };\n\n      // assign id\n      let id;\n      if (isCluster || this.options.generateId) {\n        // optionally generate id for points\n        id = data[k + OFFSET_ID];\n      } else {\n        // keep id if already assigned\n        id = this.points[data[k + OFFSET_ID]].id;\n      }\n      if (id !== undefined) f.id = id;\n      tile.features.push(f);\n    }\n  }\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n  }\n  _cluster(tree, zoom) {\n    const {\n      radius,\n      extent,\n      reduce,\n      minPoints\n    } = this.options;\n    const r = radius / (extent * Math.pow(2, zoom));\n    const data = tree.data;\n    const nextData = [];\n    const stride = this.stride;\n\n    // loop through each point\n    for (let i = 0; i < data.length; i += stride) {\n      // if we've already visited the point at this zoom level, skip it\n      if (data[i + OFFSET_ZOOM] <= zoom) continue;\n      data[i + OFFSET_ZOOM] = zoom;\n\n      // find all nearby points\n      const x = data[i];\n      const y = data[i + 1];\n      const neighborIds = tree.within(data[i], data[i + 1], r);\n      const numPointsOrigin = data[i + OFFSET_NUM];\n      let numPoints = numPointsOrigin;\n\n      // count the number of points in a potential cluster\n      for (const neighborId of neighborIds) {\n        const k = neighborId * stride;\n        // filter out neighbors that are already processed\n        if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n      }\n\n      // if there were neighbors to merge, and there are enough points to form a cluster\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        let wx = x * numPointsOrigin;\n        let wy = y * numPointsOrigin;\n        let clusterProperties;\n        let clusterPropIndex = -1;\n\n        // encode both zoom and point index on which the cluster originated -- offset by total length of features\n        const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n        for (const neighborId of neighborIds) {\n          const k = neighborId * stride;\n          if (data[k + OFFSET_ZOOM] <= zoom) continue;\n          data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n          const numPoints2 = data[k + OFFSET_NUM];\n          wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n          wy += data[k + 1] * numPoints2;\n          data[k + OFFSET_PARENT] = id;\n          if (reduce) {\n            if (!clusterProperties) {\n              clusterProperties = this._map(data, i, true);\n              clusterPropIndex = this.clusterProps.length;\n              this.clusterProps.push(clusterProperties);\n            }\n            reduce(clusterProperties, this._map(data, k));\n          }\n        }\n        data[i + OFFSET_PARENT] = id;\n        nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n        if (reduce) nextData.push(clusterPropIndex);\n      } else {\n        // left points as unclustered\n        for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n        if (numPoints > 1) {\n          for (const neighborId of neighborIds) {\n            const k = neighborId * stride;\n            if (data[k + OFFSET_ZOOM] <= zoom) continue;\n            data[k + OFFSET_ZOOM] = zoom;\n            for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n          }\n        }\n      }\n    }\n    return nextData;\n  }\n\n  // get index of the point from which the cluster originated\n  _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  }\n\n  // get zoom of the point from which the cluster originated\n  _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  }\n  _map(data, i, clone) {\n    if (data[i + OFFSET_NUM] > 1) {\n      const props = this.clusterProps[data[i + OFFSET_PROP]];\n      return clone ? Object.assign({}, props) : props;\n    }\n    const original = this.points[data[i + OFFSET_ID]].properties;\n    const result = this.options.map(original);\n    return clone && result === original ? Object.assign({}, result) : result;\n  }\n}\nfunction getClusterJSON(data, i, clusterProps) {\n  return {\n    type: 'Feature',\n    id: data[i + OFFSET_ID],\n    properties: getClusterProperties(data, i, clusterProps),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(data[i]), yLat(data[i + 1])]\n    }\n  };\n}\nfunction getClusterProperties(data, i, clusterProps) {\n  const count = data[i + OFFSET_NUM];\n  const abbrev = count >= 10000 ? `${Math.round(count / 1000)}k` : count >= 1000 ? `${Math.round(count / 100) / 10}k` : count;\n  const propIndex = data[i + OFFSET_PROP];\n  const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n  return Object.assign(properties, {\n    cluster: true,\n    cluster_id: data[i + OFFSET_ID],\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n  const sin = Math.sin(lat * Math.PI / 180);\n  const y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n  const y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}","map":{"version":3,"names":["KDBush","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","nodeSize","log","generateId","reduce","map","props","fround","Math","tmp","x","Float32Array","OFFSET_ZOOM","OFFSET_ID","OFFSET_PARENT","OFFSET_NUM","OFFSET_PROP","Supercluster","constructor","options","Object","assign","create","trees","Array","stride","clusterProps","load","points","console","time","timerId","length","data","i","p","geometry","lng","lat","coordinates","lngX","y","latY","push","Infinity","tree","_createTree","timeEnd","z","now","Date","_cluster","numItems","getClusters","bbox","zoom","minLng","minLat","max","min","maxLng","maxLat","easternHem","westernHem","concat","_limitZoom","ids","range","clusters","id","k","getClusterJSON","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","r","pow","within","children","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","result","skipped","child","cluster","point_count","add","finish","isCluster","tags","px","py","getClusterProperties","f","type","round","undefined","floor","nextData","neighborIds","numPointsOrigin","numPoints","neighborId","wx","wy","clusterProperties","clusterPropIndex","numPoints2","_map","j","clone","original","xLng","yLat","count","abbrev","propIndex","point_count_abbreviated","sin","PI","y2","atan","exp"],"sources":["/Users/yoomin/Documents/GitHub/tabi/node_modules/supercluster/index.js"],"sourcesContent":["\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}